{"ast":null,"code":"import axios from 'axios';\nconst api = axios.create({\n  baseURL: 'http://localhost:5000/api',\n  withCredentials: true\n});\nlet isRefreshing = false;\nlet failedQueue = [];\nconst processQueue = (error, token = null) => {\n  failedQueue.forEach(prom => {\n    if (error) prom.reject(error);else prom.resolve(token);\n  });\n  failedQueue = [];\n};\n\n// Response interceptor: Handles 401, refreshes, retries\napi.interceptors.response.use(response => response, async error => {\n  const originalRequest = error.config;\n  if (error.response && error.response.status === 401 && !originalRequest._retry) {\n    originalRequest._retry = true;\n    if (isRefreshing) {\n      return new Promise((resolve, reject) => {\n        failedQueue.push({\n          resolve,\n          reject\n        });\n      }).then(token => {\n        originalRequest.headers[\"Authorization\"] = \"Bearer \" + token;\n        return api(originalRequest);\n      }).catch(err => Promise.reject(err));\n    }\n    isRefreshing = true;\n    try {\n      const {\n        data\n      } = await api.post('/auth/refresh-token', {},\n      // empty body\n      {\n        withCredentials: true\n      });\n      // Save new accessToken\n      localStorage.setItem('token', data.accessToken);\n      // Set as default for new requests\n      api.defaults.headers.common[\"Authorization\"] = \"Bearer \" + data.accessToken;\n      // Set for this retry\n      originalRequest.headers[\"Authorization\"] = \"Bearer \" + data.accessToken;\n      processQueue(null, data.accessToken);\n      return api(originalRequest);\n    } catch (err) {\n      processQueue(err, null);\n      localStorage.removeItem(\"token\");\n      localStorage.removeItem(\"user\");\n      window.location.href = \"/\";\n      return Promise.reject(err);\n    } finally {\n      isRefreshing = false;\n    }\n  }\n  return Promise.reject(error);\n});\n\n// Request interceptor: Attaches access token to all requests\napi.interceptors.request.use(config => {\n  const token = localStorage.getItem('token');\n  if (token) {\n    config.headers[\"Authorization\"] = \"Bearer \" + token;\n  }\n  return config;\n}, error => Promise.reject(error));\nexport default api;","map":{"version":3,"names":["axios","api","create","baseURL","withCredentials","isRefreshing","failedQueue","processQueue","error","token","forEach","prom","reject","resolve","interceptors","response","use","originalRequest","config","status","_retry","Promise","push","then","headers","catch","err","data","post","localStorage","setItem","accessToken","defaults","common","removeItem","window","location","href","request","getItem"],"sources":["E:/Fadz_web/FADZtrack-web-/frontend/src/api/axiosInstance.js"],"sourcesContent":["import axios from 'axios';\r\n\r\nconst api = axios.create({\r\n  baseURL: 'http://localhost:5000/api',\r\n  withCredentials: true \r\n});\r\n\r\nlet isRefreshing = false;\r\nlet failedQueue = [];\r\n\r\nconst processQueue = (error, token = null) => {\r\n  failedQueue.forEach(prom => {\r\n    if (error) prom.reject(error);\r\n    else prom.resolve(token);\r\n  });\r\n  failedQueue = [];\r\n};\r\n\r\n// Response interceptor: Handles 401, refreshes, retries\r\napi.interceptors.response.use(\r\n  response => response,\r\n  async error => {\r\n    const originalRequest = error.config;\r\n    if (\r\n      error.response &&\r\n      error.response.status === 401 &&\r\n      !originalRequest._retry\r\n    ) {\r\n      originalRequest._retry = true;\r\n      if (isRefreshing) {\r\n        return new Promise((resolve, reject) => {\r\n          failedQueue.push({ resolve, reject });\r\n        })\r\n          .then(token => {\r\n            originalRequest.headers[\"Authorization\"] = \"Bearer \" + token;\r\n            return api(originalRequest);\r\n          })\r\n          .catch(err => Promise.reject(err));\r\n      }\r\n      isRefreshing = true;\r\n      try {\r\n        const { data } = await api.post(\r\n          '/auth/refresh-token',\r\n          {}, // empty body\r\n          { withCredentials: true }\r\n        );\r\n        // Save new accessToken\r\n        localStorage.setItem('token', data.accessToken);\r\n        // Set as default for new requests\r\n        api.defaults.headers.common[\"Authorization\"] = \"Bearer \" + data.accessToken;\r\n        // Set for this retry\r\n        originalRequest.headers[\"Authorization\"] = \"Bearer \" + data.accessToken;\r\n        processQueue(null, data.accessToken);\r\n        return api(originalRequest);\r\n      } catch (err) {\r\n        processQueue(err, null);\r\n        localStorage.removeItem(\"token\");\r\n        localStorage.removeItem(\"user\");\r\n        window.location.href = \"/\";\r\n        return Promise.reject(err);\r\n      } finally {\r\n        isRefreshing = false;\r\n      }\r\n    }\r\n    return Promise.reject(error);\r\n  }\r\n);\r\n\r\n// Request interceptor: Attaches access token to all requests\r\napi.interceptors.request.use(\r\n  config => {\r\n    const token = localStorage.getItem('token');\r\n    if (token) {\r\n      config.headers[\"Authorization\"] = \"Bearer \" + token;\r\n    }\r\n    return config;\r\n  },\r\n  error => Promise.reject(error)\r\n);\r\n\r\nexport default api;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}